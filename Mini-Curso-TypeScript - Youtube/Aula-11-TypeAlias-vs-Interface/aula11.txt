// Type Alias vs Interface

// Type Alias

// Definição
type GameT = {
  title: string;
};

type DLCT = {
  extra: string;
};

// Intersection
type GameCollectionT = Game & DLCT;

// Implements
class CreateGame implements GameCollection {}

// Declarar função
type getSimiliarsT = (title: string) => void;

// ============ Diferenças ============

// Permite declarar tipos primitivos
type IDT = string | number;

// Pode declarar tuplas normalmente
type TpleT = [number, number];
[1, 2] as TupleT;

// Apenas uma declaração por escopo
type JQueryT = {a: string};
type JQueryT = {b: string};

======================================================================================================================
// Interfaces 

// Definição
interface Game {
  title: string;
};

interface DLC {
  extra: string;
};

//Intersection | extend
interface GameCollection extends Game, DLC {}

// Implements 
class CreateGame implements GameCollection {}

// Declarar função
interface getSimiliars {
 (title: string): void;
}

// Mais recomendado na maioria das vezes.

// ============ Diferenças ============

interface ID extends number {}  // Está incorreto

interface Tuple {
  0: number; 
  1: number;
}
[1, 2, 3] as Tuple;  // Tupla não funciona na interface

// Pode ter multiplas declarações e ele une de mesmo nome

interface JQuery {
  a: string
};

interface JQuery {
  b: string;
};

const $: JQuery = {
  a: "bla",
  b: "foo"
};

// Vantagem: Quando tiver criando libs, prefira Interfaces, por que são mais extensiveis!
// Vantagem: Criando objetos/classes (POO).